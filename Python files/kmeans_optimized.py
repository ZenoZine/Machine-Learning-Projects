# -*- coding: utf-8 -*-
"""kmeans_optimized.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1cQAI5IAWNnrhbpPaheoi1JaYJWZ6ck9y
"""

import numpy as np
import matplotlib.pyplot as plt


k = 2

N = 1000
D = 2

X1 = np.random.randn(int(N/2), D)
X2 = np.random.randn(int(N/2), D) + [2, 3]
X = np.concatenate((X1, X2), axis=0)

plt.scatter(X[:int(N/2), 0], X[:int(N/2), 1], c='r')
plt.scatter(X[int(N/2):, 0], X[int(N/2):, 1], c='g')

av_pt = np.mean(X, axis=0)
var_pt = np.var(X, axis=0)

mus = np.zeros((k, D))
mus[0, :] = av_pt + var_pt
mus[1, :] = av_pt - var_pt


plt.scatter(X[:, 0], X[:, 1], s=1)
mucols = [[0.5, 0, 0], [0, 0.5, 0]]
cols = [[1, 0, 0], [0, 1, 0]]
for ix in range(k):
  plt.scatter(mus[ix, 0], mus[ix, 1], c=mucols[ix])


#plt.scatter(av_pt[0], av_pt[1], c='k')

rnk = np.zeros((N, k))
for ix in range(N):
  rnk[ix, np.random.randint(2)] = 1

cl1ixs = np.where(np.array(rnk[:, 0]==1, dtype='int'))[0]
cl2ixs = np.where(np.array(rnk[:, 1]==1, dtype='int'))[0]

plt.scatter(X[cl1ixs, 0], X[cl1ixs, 1], c=cols[0])
plt.scatter(X[cl2ixs, 0], X[cl2ixs, 1], c=cols[1])

import scipy.spatial.distance as dist


# EXPECTATION
dists = dist.cdist(X, mus)
rnk = 1 - np.argsort(dists, axis=1)

cl1ixs = np.where(np.array(rnk[:, 0]==1, dtype='int'))[0]
cl2ixs = np.where(np.array(rnk[:, 1]==1, dtype='int'))[0]

plt.scatter(X[cl1ixs, 0], X[cl1ixs, 1], c=cols[0])
plt.scatter(X[cl2ixs, 0], X[cl2ixs, 1], c=cols[1])
for ix in range(k):
  plt.scatter(mus[ix, 0], mus[ix, 1], s=100, c=mucols[ix])

# MAXIMIZATION

for ix in range(k): # for each class
  prototype = np.array([0.0, 0.0]) # initialize a prototype
  for d in range(D): # for each prototype's dimension
    c = 0.0 # initialize a counter
    for n in range(N): # for each data point
      if rnk[n, d] != ix: # if data point belongs to class ix
        c += 1 # increase a counter
        prototype[d] += X[n, d] # add it to prototype dim
    prototype[d] /= c
  #print(prototype)
  mus[ix, :] = prototype[d]

plt.scatter(X[cl1ixs, 0], X[cl1ixs, 1], c=cols[0])
plt.scatter(X[cl2ixs, 0], X[cl2ixs, 1], c=cols[1])
for ix in range(k):
  plt.scatter(mus[ix, 0], mus[ix, 1], s=100, c=mucols[ix])



# EXPECTATION
dists = dist.cdist(X, mus)
rnk = 1 - np.argsort(dists, axis=1)

cl1ixs = np.where(np.array(rnk[:, 0]==1, dtype='int'))[0]
cl2ixs = np.where(np.array(rnk[:, 1]==1, dtype='int'))[0]

plt.scatter(X[cl1ixs, 0], X[cl1ixs, 1], c=cols[0])
plt.scatter(X[cl2ixs, 0], X[cl2ixs, 1], c=cols[1])
for ix in range(k):
  plt.scatter(mus[ix, 0], mus[ix, 1], s=100, c=mucols[ix])

# MAXIMIZATION

mus = rnk.T.dot(X) / np.sum(rnk, axis=0)

plt.scatter(X[cl1ixs, 0], X[cl1ixs, 1], c=cols[0])
plt.scatter(X[cl2ixs, 0], X[cl2ixs, 1], c=cols[1])
for ix in range(k):
  plt.scatter(mus[ix, 0], mus[ix, 1], s=100, c=mucols[ix])

# EXPECTATION
dists = dist.cdist(X, mus)
rnk = 1 - np.argsort(dists, axis=1)

cl1ixs = np.where(np.array(rnk[:, 0]==1, dtype='int'))[0]
cl2ixs = np.where(np.array(rnk[:, 1]==1, dtype='int'))[0]

plt.scatter(X[cl1ixs, 0], X[cl1ixs, 1], c=cols[0])
plt.scatter(X[cl2ixs, 0], X[cl2ixs, 1], c=cols[1])
for ix in range(k):
  plt.scatter(mus[ix, 0], mus[ix, 1], s=100, c=mucols[ix])

nr_iterations = 10
for i in range(nr_iterations):
  # EXPECTATION
  dists = dist.cdist(X, mus)
  rnk = 1 - np.argsort(dists, axis=1)
  cl1ixs = np.where(np.array(rnk[:, 0]==1, dtype='int'))[0]
  cl2ixs = np.where(np.array(rnk[:, 1]==1, dtype='int'))[0]
  # MAXIMIZATION
  mus = rnk.T.dot(X) / np.sum(rnk, axis=0)



plt.scatter(X[cl1ixs, 0], X[cl1ixs, 1], c=cols[0])
plt.scatter(X[cl2ixs, 0], X[cl2ixs, 1], c=cols[1])
for ix in range(k):
  plt.scatter(mus[ix, 0], mus[ix, 1], s=100, c=mucols[ix])

mus = rnk.T.dot(X) / np.sum(rnk, axis=0)
mus
